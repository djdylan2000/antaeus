## Antaeus

Antaeus (/√¶nÀàtiÀê…ôs/), in Greek mythology, a giant of Libya, the son of the sea god Poseidon and the Earth goddess Gaia. He compelled all strangers who were passing through the country to wrestle with him. Whenever Antaeus touched the Earth (his mother), his strength was renewed, so that even if thrown to the ground, he was invincible. Heracles, in combat with him, discovered the source of his strength and, lifting him up from Earth, crushed him to death.

Welcome to our challenge.

## The challenge

As most "Software as a Service" (SaaS) companies, Pleo needs to charge a subscription fee every month. Our database contains a few invoices for the different markets in which we operate. Your task is to build the logic that will schedule payment of those invoices on the first of the month. While this may seem simple, there is space for some decisions to be taken and you will be expected to justify them.

## Instructions

Fork this repo with your solution. Ideally, we'd like to see your progression through commits, and don't forget to update the README.md to explain your thought process.

Please let us know how long the challenge takes you. We're not looking for how speedy or lengthy you are. It's just really to give us a clearer idea of what you've produced in the time you decided to take. Feel free to go as big or as small as you want.

## Developing

Requirements:
- \>= Java 11 environment

Open the project using your favorite text editor. If you are using IntelliJ, you can open the `build.gradle.kts` file and it is gonna setup the project in the IDE for you.

### Building

```
./gradlew build
```

### Running

There are 2 options for running Anteus. You either need libsqlite3 or docker. Docker is easier but requires some docker knowledge. We do recommend docker though.

*Running Natively*

Native java with sqlite (requires libsqlite3):

If you use homebrew on MacOS `brew install sqlite`.

```
./gradlew run
```

*Running through docker*

Install docker for your platform

```
docker build -t antaeus
docker run antaeus
```

### App Structure
The code given is structured as follows. Feel free however to modify the structure to fit your needs.
```
‚îú‚îÄ‚îÄ buildSrc
|  | gradle build scripts and project wide dependency declarations
|  ‚îî src/main/kotlin/utils.kt 
|      Dependencies
|
‚îú‚îÄ‚îÄ pleo-antaeus-app
|       main() & initialization
|
‚îú‚îÄ‚îÄ pleo-antaeus-core
|       This is probably where you will introduce most of your new code.
|       Pay attention to the PaymentProvider and BillingService class.
|
‚îú‚îÄ‚îÄ pleo-antaeus-data
|       Module interfacing with the database. Contains the database 
|       models, mappings and access layer.
|
‚îú‚îÄ‚îÄ pleo-antaeus-models
|       Definition of the Internal and API models used throughout the
|       application.
|
‚îî‚îÄ‚îÄ pleo-antaeus-rest
        Entry point for HTTP REST API. This is where the routes are defined.
```

### Main Libraries and dependencies
* [Exposed](https://github.com/JetBrains/Exposed) - DSL for type-safe SQL
* [Javalin](https://javalin.io/) - Simple web framework (for REST)
* [kotlin-logging](https://github.com/MicroUtils/kotlin-logging) - Simple logging framework for Kotlin
* [JUnit 5](https://junit.org/junit5/) - Testing framework
* [Mockk](https://mockk.io/) - Mocking library
* [Sqlite3](https://sqlite.org/index.html) - Database storage engine

Happy hacking üòÅ!

## Solution

The goal was to schedule charging of invoices on the first of the month.
To accomplish this, a queue like AWS SQS or Apache Kafka could be used. I believe in keeping things simple and reducing external dependencies as much as possible, unless they are really needed(easier to understand, debug, maintain), so I instead decided to use the existing database to model queue behavior.

### Scheduling

I created a class `AbstractQueueWorker` that provides a generic re-useable framework (sort of following the Template Design Pattern) to periodically poll and process messages. This class supports running multiple worker threads in parallel, along with a configurable wait time to check for the next message if one is not currently present.

I extended this class with a class `BillingQueueWorker` that fetches scheduled payments when they are overdue and passes them on to `BillingService`, which in turn fetches the invoice from the `InvoiceService` and passes it on to the `PaymentProvider`.

`ScheduledPaymentService` is what handles scheduling an invoice as well as fetching overdue invoices for payments. When scheduling an invoice, this class calculates the first of the next calendar month and schedules it for that time. I created a mock of this class for testing the behavior called `MockScheduledPaymentService` that schedules for 15 secs in the future.



`ScheduledPayment` represents an invoice that is scheduled to be charged in the future. It has the following fields

`id` - autogenerated identifier<br/>
`invoiceId` - a reference to the invoice that needs to be charged<br/>
`scheduledTime` - time at (after) which the invoice can be charged<br/>
`status` - whether pending, successful or failed<br/>
`attempt` & `lastStartedAt` - are to handle retries<br/>

### SQL Query explained:

The SQL query to poll is roughly of the form:

```
SELECT * FROM ScheduledPayment
WHERE
  ScheduledPayment.scheduled_time < CURRENT_TIMESTAMP
  AND ScheduledPayment.status <> 'SUCCESS'
  AND (ScheduledPayment.last_started_at IS NULL
    OR (ScheduledPayment.attempt < MAX_ATTEMPTS
      AND ScheduledPayment.last_started_at < CURRENT_TIMESTAMP - TIMEOUT
    )
  )
LIMIT 1
```

Here are the components explained:
`scheduledTime < CURRENT_TIMESTAMP & status != SUCCESS` - this will fetch all scheduled payments that haven't been paid and that are in the past. We could put a lower bound on the scheduled time, but it needs to be chosen carefully, as if the system goes down and comes back up, if the difference between current time and scheduled time grows too large it wouldn't get picked.<br/>

`lastStartedOn = null` implies the job was never picked<br/>
`attempt < MAX_ATTEMPTS` implies the job hasn't exhausted the maximum number of retries we have configured<br/>
`lastStartedAt < CURRENT_TIMESTAMP - TIMEOUT` implies at least TIMEOUT amount of time has elapsed since this job was last picked up.<br/>

The method `AntaeusDal#pollNextScheduledPayment` selects and locks the row retrieved by the above query by using SELECT FOR UPDATE, and then updates its lastStartedAt and attempts in a single transaction. Updating lastStartedAt prevents other workers in the distributed system from picking up the same job. Updating attempts on picking up the job handles the case that the job causes the system to crash whenever picked up (faulty job) - it won't get picked unlimited times and deteriorate the system performance.

After completing processing the job, the scheduled job's status is changed to SUCCESS to prevent it from being picked again. We also update the invoice status to SUCCESS in the same transaction to prevent loss of integrity. One assumption here is that our payment providers charge method is idempotent - i.e. calling it multiple times for the same invoice id won't double charge the customer. If it is not idempotent, this could happen - charge succeeds with the payment provider, database goes down and we don't update the transaction on our end despite retries.
A way to avoid this if it is not idempotent is to have the payment provider provide an API to check the status of an invoice, so we do that check before charging an invoice.

### Application setup

Since there is already data in the DB, I've modified the main function to fetch invoices using the invoice service and schedule them by passing pending invoices to scheduledService. As mentioned previously, to schedule for the near future, we can initialize scheduledService to `MockScheduledPaymentService` instead of `ScheduledPaymentService` here.


### Scope for improvements and extension

Being an assignment, I had to scope the problem and solution. However I'd like to mention some ideas I had in mind of how this could be improved and extended

1. Have a REST API to create an invoice. When creating an invoice it can be scheduled as well for payment in the next month
2. Have customer preferences on when to be billed. Some customers may prefer to be billed for example on the 3rd of the month, at a specific time.
3. Handle payment failures better. Network failures can be retried soon with exponential backoff. Customer not having enough balance can trigger an email to the customer and can have a larger retry of 12 hours or a day. Currency mismatch can also trigger an email for the customer to correct their preferences. Customer missing could alert the account manager or customer success manager of the account and not have automatic retries. We could provide an API for the AM/CSM to manually redrive such failed invoice charges.
4. The select query can be improved by doing an order by rand() when polling messages
5. Generate a report of failed payments at the end of the day
6. Right now I've used an index on the status column of `ScheduledPaymentTable`, which would help filter non SUCCESS messages faster than reading through the whole table. A better approach would be to move processed messages to another "history" table.
7. I normally prefer having all Manager/Service classes be an interface, and have the logic in an Impl class that implements the interface. Following the Dependency inversion principle this way helps to easily mock and test classes or substitute them for other implementations in the future easily.
8. I would move all constants to a config file, for example Spring allows you to define such constants in an `application.properties` file
